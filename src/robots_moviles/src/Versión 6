#!/usr/bin/env python
import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import OccupancyGrid
from random import randint
import numpy as np
import openpyxl
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import time

class MapExplorer:
    def __init__(self):
        rospy.init_node('map_explorer', anonymous=True)
        self.map_data = None
        self.counter = 1
        self.map_subscriber = rospy.Subscriber('/map', OccupancyGrid, self.map_callback)
        self.goal_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.goal_client.wait_for_server()
        self.explored_cells = set()

    def map_callback(self, map_msg):
        rospy.loginfo('Mapa recibido')
        self.map_data = map_msg
        self.map_matriz = np.array(self.map_data.data).reshape((self.map_data.info.height, self.map_data.info.width))
        self.extract_reduced_map()
        self.save_map_data_to_excel('map_data_' + str(self.counter) + '.xlsx')
        self.visualize_map_data('map_data_' + str(self.counter) + '.xlsx')
        self.explore()
        self.counter += 1

    def save_map_data_to_excel(self,filename):
        if self.map_data is not None:
            wb = openpyxl.Workbook()
            ws = wb.active
            width = self.map_data.info.width
            height = self.map_data.info.height

            for y in range(height):
                for x in range(width):
                    index = y * width + x
                    ws.cell(row=y+1, column=x+1, value=self.map_data.data[index])
            wb.save(filename)
            print(f'Mapa guardado en {filename}')

    def visualize_map_data(self,file_path):
        # Cargar datos desde el archivo Excel
        wb = openpyxl.load_workbook(file_path)
        ws = wb.active
        # Leer datos de la hoja activa
        data = []
        for row in ws.iter_rows(values_only=True):
            data.append(row)
        # Convertir los datos a una matriz numpy
        data = np.array(data)
        # Mapear los valores a colores
        cmap_colors = [(0.5, 0.5, 0.5), (0, 0, 1), (1, 1, 1), (1, 0, 0)]  # Gris, Azul, Blanco, Rojo
        cmap = ListedColormap(cmap_colors)
        normalized_map_data = data.astype(float) / 100  # Normalizamos al rango [0, 1]
        # Graficar los datos
        plt.imshow(normalized_map_data, cmap=cmap, origin='lower', vmin=-0.5, vmax=1.5)  # Ajustar los límites de los valores para que los colores coincidan
        #plt.colorbar()
        plt.savefig('map_data_' + str(self.counter) + '.png')  # Guardar la imagen como un archivo PNG
        print(f'Imagen guardada map_data_' + str(self.counter) + '.png')
        plt.close()

    # Función para extraer la región reducida del mapa
    def extract_reduced_map(self):
        if self.map_matriz is not None:
            print('Extrayendo región reducida...')
            width = self.map_matriz.shape[1]
            height = self.map_matriz.shape[0]
            border_indices = np.where(self.map_matriz == 100)
            min_row, max_row = min(border_indices[0]), max(border_indices[0])
            min_col, max_col = min(border_indices[1]), max(border_indices[1])
            # Asignar el valor 50 a las celdas fuera del área reducida que no tienen el valor 100
            self.map_matriz[:min_row][self.map_matriz[:min_row] != 100] = 50
            self.map_matriz[max_row+1:][self.map_matriz[max_row+1:] != 100] = 50
            self.map_matriz[:, :min_col][self.map_matriz[:, :min_col] != 100] = 50
            self.map_matriz[:, max_col+1:][self.map_matriz[:, max_col+1:] != 100] = 50
            self.map_data.data = list(self.map_data.data)
            for y in range(height):
                for x in range(width):
                    index = int(y * width + x) 
                    self.map_data.data[index]=self.map_matriz[y][x]
    
    
    def explore(self):
        if self.map_data is not None:
            rospy.loginfo('Explorando el mapa...')
            width = self.map_data.info.width
            height = self.map_data.info.height
            resolution = self.map_data.info.resolution

            # Obtener coordenadas de los puntos no explorados
            unexplored_points = []
            for y in range(height):
                for x in range(width):
                    index = int(y * width + x)  # Convertir a entero
                    if self.map_data.data[index] == -1 and (x, y) not in self.explored_cells:
                        unexplored_points.append([x * resolution + self.map_data.info.origin.position.x,
                                                  y * resolution + self.map_data.info.origin.position.y])

            if unexplored_points:
                # Elegir el punto con la mayor cantidad de valores -1
                max_count_point = max(unexplored_points, key=lambda point: self.count_adjacent_cells(point[0], point[1]))

                if self.is_point_clear(max_count_point[0], max_count_point[1]):
                    rospy.loginfo(f"Navegando hacia ({max_count_point[0]}, {max_count_point[1]})...")
                    goal = MoveBaseGoal()
                    goal.target_pose.header.frame_id = "map"
                    goal.target_pose.header.stamp = rospy.Time.now()
                    goal.target_pose.pose.position.x = max_count_point[0]
                    goal.target_pose.pose.position.y = max_count_point[1]
                    goal.target_pose.pose.orientation.w = 1.0

                    self.goal_client.send_goal(goal)
                    self.goal_client.wait_for_result()

                    rospy.loginfo(f"Posición ({max_count_point[0]}, {max_count_point[1]}) alcanzada!")

                    # Agregar el punto explorado a la lista de celdas exploradas
                    self.explored_cells.add((max_count_point[0], max_count_point[1]))
                else:
                    rospy.loginfo(f"El punto ({max_count_point[0]}, {max_count_point[1]}) no es accesible. Buscando otro punto...")
            else:
                rospy.loginfo("¡Todos los puntos están explorados!")

            rospy.loginfo('Exploración terminada.')

    def count_adjacent_cells(self, x, y):
        # Contar la cantidad de celdas adyacentes con valor -1 al punto (x, y)
        count = 0
        for dx in range(-1, 2):
            for dy in range(-1, 2):
                if dx == 0 and dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.map_data.info.width and 0 <= ny < self.map_data.info.height:
                    index = int(ny * self.map_data.info.width + nx)  # Convertir a entero
                    if self.map_data.data[index] == -1:
                        count += 1
        print (f"coordenadas: ({ny},{nx})")
        return count

    def is_point_clear(self, x, y):
        # Verifica si el punto (x, y) está libre de obstáculos y paredes
        index = int((y - self.map_data.info.origin.position.y) / self.map_data.info.resolution) * self.map_data.info.width + int((x - self.map_data.info.origin.position.x) / self.map_data.info.resolution)
        if 0 <= index < len(self.map_data.data):
            return self.map_data.data[index] == -1 and self.map_data.data[index] != 100
        else:
            return False

if __name__ == '__main__':
    try:
        explorer = MapExplorer()
        rospy.spin()
        
    except rospy.ROSInterruptException:
        MapExplorer.save_map_data_to_excel('map_data_' + str(MapExplorer.counter) + '.xlsx')
        MapExplorer.visualize_map_data('map_data_' + str(MapExplorer.counter) + '.xlsx')
        rospy.loginfo("Exploración terminada.")

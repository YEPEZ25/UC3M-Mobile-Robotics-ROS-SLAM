#!/usr/bin/env python

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import OccupancyGrid
from random import randint

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import numpy as np
import math

map_data = None

def map_callback(map_msg):
    global map_data
    print('Mapa recibido')
    map_data = map_msg
    map_matriz = np.array(map_data.data).reshape((map_data.info.height, map_data.info.width))
    extract_reduced_map(map_matriz)
    plot_map()    
    select_and_publish_goal()

def plot_map():
    global map_data
    if map_data is not None:
        width = map_data.info.width
        height = map_data.info.height
        data = map_data.data
        map_array = np.array(data).reshape((height, width))
        # Definir el mapa de colores personalizado
        cmap_colors = [(0.5, 0.5, 0.5), (0, 0, 1), (1, 1, 1), (1, 0, 0)]  # Gris, Azul, Blanco, Rojo
        cmap = ListedColormap(cmap_colors)
        # Normalizar el mapa de datos
        normalized_map_data = map_array.astype(float) / 100  # Normalizamos al rango [0, 1]
        # Graficar la matriz usando el mapa de colores personalizado
        plt.imshow(normalized_map_data, cmap=cmap, origin='lower', vmin=-0.5, vmax=1.5)  # Ajustar los límites de los valores para que los colores coincidan
        #plt.colorbar(label='Occupancy Status')
        plt.title('Occupancy Grid Map')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()

# Función para extraer la región reducida del mapa
def extract_reduced_map(map_matriz):
    global map_data
    if map_matriz is not None:
        print('Extrayendo región reducida...')
        width = map_matriz.shape[1]
        height = map_matriz.shape[0]
        border_indices = np.where(map_matriz == 100)
        min_row, max_row = min(border_indices[0]), max(border_indices[0])
        min_col, max_col = min(border_indices[1]), max(border_indices[1])
        # Asignar el valor 50 a las celdas fuera del área reducida que no tienen el valor 100
        map_matriz[:min_row][map_matriz[:min_row] != 100] = 50
        map_matriz[max_row+1:][map_matriz[max_row+1:] != 100] = 50
        map_matriz[:, :min_col][map_matriz[:, :min_col] != 100] = 50
        map_matriz[:, max_col+1:][map_matriz[:, max_col+1:] != 100] = 50
        map_data.data = list(map_data.data)
        for y in range(height):
            for x in range(width):
                index = int(y * width + x) 
                map_data.data[index]=map_matriz[y][x]

def select_and_publish_goal():
    global map_data
    if map_data is not None:
        print('Eligiendo destino...')
        width = map_data.info.width
        height = map_data.info.height
        # Obteniendo la posición actual del robot en el mapa
        origin_x = map_data.info.origin.position.x
        origin_y = map_data.info.origin.position.y
        current_x = int((0 - origin_x) / map_data.info.resolution)
        current_y = int((0 - origin_y) / map_data.info.resolution)
        print(f'Robot está localizado en: ({current_y},{current_x}) / ({origin_y},{origin_x})')
        max_distance = -1
        target_x = 0
        target_y = 0

        for y in range(height):
            for x in range(width):
                index = int(y * width + x)  # Convertir a entero
                # Si la celda está libre (0)
                if map_data.data[index] == -1:
                    # Calcula la distancia euclidiana desde la posición actual del robot
                    distance = math.sqrt((current_x - x) ** 2 + (current_y - y) ** 2)
                    # Actualiza el objetivo si la distancia es mayor
                    if distance > max_distance:
                        max_distance = distance
                        target_x = x
                        target_y = y
                        i=index
        goal_client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
        goal_client.wait_for_server()
        
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()
        go_x = target_x * map_data.info.resolution + map_data.info.origin.position.x
        go_y = target_y * map_data.info.resolution + map_data.info.origin.position.y
        goal.target_pose.pose.position.x = go_x
        goal.target_pose.pose.position.y = go_y
        goal.target_pose.pose.orientation.w = 1.0
        print(f'Destino elegido. Navegando hasta el punto...({target_y},{target_x}) / ({go_y},{go_x})')
        goal_client.send_goal(goal)
        wait = goal_client.wait_for_result()
        print('Punto alcanzado!')


if __name__ == '__main__':
    try:
        rospy.init_node('exploration', anonymous=True)
        map_subscriber = rospy.Subscriber('/map', OccupancyGrid, map_callback)
        
        rate = rospy.Rate(1)

        while not rospy.is_shutdown():
            rate.sleep()

    except rospy.ROSInterruptException:
        rospy.loginfo("Exploration finished.")

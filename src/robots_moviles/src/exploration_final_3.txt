import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import OccupancyGrid
from random import randint

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import numpy as np
import math

class MapExplorer:
    def __init__(self):
        rospy.init_node('map_explorer', anonymous=True)
        self.map_data = None
        self.map_subscriber = rospy.Subscriber('/map', OccupancyGrid, self.map_callback)
        self.goal_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.goal_client.wait_for_server()

    def map_callback(self, map_msg):
        rospy.loginfo('Mapa recibido')
        self.map_data = map_msg
        self.map_matriz = np.array(self.map_data.data).reshape((self.map_data.info.height, self.map_data.info.width))
        self.extract_reduced_map()
        self.plot_map()
        self.explore()

    def plot_map(self):
        if self.map_data is not None:
            width = self.map_data.info.width
            height = self.map_data.info.height
            data = self.map_data.data
            map_array = np.array(data).reshape((height, width))
            # Definir el mapa de colores personalizado
            cmap_colors = [(0.5, 0.5, 0.5), (0, 0, 1), (1, 1, 1), (1, 0, 0)]  # Gris, Azul, Blanco, Rojo
            cmap = ListedColormap(cmap_colors)
            # Normalizar el mapa de datos
            normalized_map_data = map_array.astype(float) / 100  # Normalizamos al rango [0, 1]
            # Graficar la matriz usando el mapa de colores personalizado
            plt.imshow(normalized_map_data, cmap=cmap, origin='lower', vmin=-0.5, vmax=1.5)  # Ajustar los límites de los valores para que los colores coincidan
            #plt.colorbar(label='Occupancy Status')
            plt.title('Occupancy Grid Map')
            plt.xlabel('X')
            plt.ylabel('Y')
            plt.show()

    # Función para extraer la región reducida del mapa
    def extract_reduced_map(self):
        if self.map_matriz is not None:
            print('Extrayendo región reducida...')
            width = self.map_matriz.shape[1]
            height = self.map_matriz.shape[0]
            border_indices = np.where(self.map_matriz == 100)
            min_row, max_row = min(border_indices[0]), max(border_indices[0])
            min_col, max_col = min(border_indices[1]), max(border_indices[1])
            # Asignar el valor 50 a las celdas fuera del área reducida que no tienen el valor 100
            self.map_matriz[:min_row][self.map_matriz[:min_row] != 100] = 50
            self.map_matriz[max_row+1:][self.map_matriz[max_row+1:] != 100] = 50
            self.map_matriz[:, :min_col][self.map_matriz[:, :min_col] != 100] = 50
            self.map_matriz[:, max_col+1:][self.map_matriz[:, max_col+1:] != 100] = 50
            self.map_data.data = list(self.map_data.data)
            for y in range(height):
                for x in range(width):
                    index = int(y * width + x) 
                    self.map_data.data[index]=self.map_matriz[y][x]

    def explore(self):
        if self.map_data is not None:
            print('Eligiendo destino...')
            width = self.map_data.info.width
            height = self.map_data.info.height
            # Obteniendo la posición actual del robot en el mapa
            origin_x = self.map_data.info.origin.position.x
            origin_y = self.map_data.info.origin.position.y
            current_x = int((0 - origin_x) / self.map_data.info.resolution)
            current_y = int((0 - origin_y) / self.map_data.info.resolution)
            print(f'Robot está localizado en: ({current_y},{current_x}) / ({origin_y},{origin_x})')
            max_distance = -1
            target_x = 0
            target_y = 0

            for y in range(height):
                for x in range(width):
                    index = int(y * width + x)  # Convertir a entero
                    # Si la celda está libre (0)
                    if self.map_data.data[index] == -1:
                        # Calcula la distancia euclidiana desde la posición actual del robot
                        distance = math.sqrt((current_x - x) ** 2 + (current_y - y) ** 2)
                        # Actualiza el objetivo si la distancia es mayor
                        if distance > max_distance:
                            max_distance = distance
                            target_x = x
                            target_y = y
                            i=index
            
            goal = MoveBaseGoal()
            goal.target_pose.header.frame_id = "map"
            goal.target_pose.header.stamp = rospy.Time.now()
            go_x = target_x * self.map_data.info.resolution + self.map_data.info.origin.position.x
            go_y = target_y * self.map_data.info.resolution + self.map_data.info.origin.position.y
            goal.target_pose.pose.position.x = go_x
            goal.target_pose.pose.position.y = go_y
            goal.target_pose.pose.orientation.w = 1.0
            print(f'Destino elegido. Navegando hasta el punto...({target_y},{target_x}) / ({go_y},{go_x})')
            self.goal_client.send_goal(goal)
            self.goal_client.wait_for_result()
            print('Punto alcanzado!')

if __name__ == '__main__':
    try:
        explorer = MapExplorer()
        rospy.spin()

    except rospy.ROSInterruptException:
        rospy.loginfo("Exploración terminada.")